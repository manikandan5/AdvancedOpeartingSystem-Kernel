1) Our program does output some garbage values. The reason behind this is context switching or inter switching. Since there is 
no synchronization technique applied between the consumer and the producer, the switching happens at random, due to which we get 
some garbage values. Since the thread of producer was created before the consumer and also since the producer contains arithmetic
operations, it is assigned a priority higher than the consumer and it finishes earlier than it.

2)	No, all the produced values are not getting consumed, because there is no synchronization between the producer and consumer, 
and hence the producer executes on a priority and each value generated by it is not consumed by the consumer. The time for which 
the producer executes, the machine instructions which it executes increments the value of n, without waiting for the consumer to 
fetch it. Hence, the consumer does not receive each value generated.

3)	We did the study required to implement the code and both of us implemented it together. The producer implements a for loop 
which increments the value of a global variable n and also prints the value for it. It does it till the count which can be set 
by us and if not set by us has a default value of 2000. The consumer on the other hand fetches this value of n generated by the 
producer and prints it on the console. Since in an ideal scenario, each value of n generated by the producer should have been 
consumed by the consumer, the loop in the consumer also iterates to count. We did some modifications in the makefile to compile 
the app folder which was used to store producer and consumer files.
